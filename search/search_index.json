{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"emzdev.github.io","text":"<p>Game Development notes, guides and documentation with a focus on Unreal Engine.</p> <p>About</p> <p>This is where I document my personal notes related to game development, with a focus  on Unreal Engine.  </p> <p>I tend to cover topics that I didn't find much information about, and had to figure out by myself.  I also aim to cover some frequently asked topics in the form of guides to contribute to the gamedev community,  and to have an easier time to onboard people that I work with.</p> <p>Feel free to take a look around, maybe you'll find something useful. </p>"},{"location":"eos/","title":"WIP","text":""},{"location":"eos/unlinking-user-eos/","title":"WIP","text":""},{"location":"steamworks/","title":"WIP","text":""},{"location":"steamworks/creating-beta-builds/","title":"WIP","text":""},{"location":"steamworks/uploading-build/","title":"WIP","text":""},{"location":"ue5/","title":"Unreal Engine 5","text":"<p>Welcome to the Unreal Engine 5 section</p>"},{"location":"ue5/accessing-connected-players-client/","title":"Accessing other connected players from a client","text":"<p>You can access other connected players through the PlayerStates framework class. PlayerStates represents a participant of a game and they're are fully replicated to all clients unlike PlayerController (that only exist on the server and the owning client).</p>"},{"location":"ue5/accessing-connected-players-client/#gamestates-playerarray","title":"GameState's PlayerArray","text":"<p>The GameState comes with a PlayerArray which holds an array of all PlayerStates. The array itself isn't replicated, but  maintained by both the server and the clients.</p> <ul> <li> <p>When a client spawns a PlayerState, it will be added to the PlayerArray  in <code>APlayerState::PostInitializeComponents</code> (if the GameState is available).</p> </li> <li> <p>If the GameState is not yet available, all the PlayerStates will get added once the GameState gets spawned and the  <code>AGameStateBase::PostInitializeComponents</code> is called.</p> </li> </ul> <p>Note</p> <p>There is no order in which the PlayerStates and the GameState are guaranteed to be received in on the clients (i.e. PlayerStates      can be spawned before the GameState). Be aware of this when trying to access them when the game starts.</p>"},{"location":"ue5/accessing-connected-players-client/#knowing-when-a-playerstate-has-been-synced","title":"Knowing when a PlayerState has been synced","text":"<p><code>APlayerState::PostInitializeComponents</code> is called before the initial replicated values are read. In order to know when a PlayerState  has received its initial replicated properties, you can use <code>AActor::PostNetInit</code> on the PlayerState</p>"},{"location":"ue5/accessing-logs/","title":"WIP","text":""},{"location":"ue5/blueprint-communication/","title":"Blueprint Communication","text":""},{"location":"ue5/blueprint-communication/#intro","title":"Intro","text":"<p>Jumping into Blueprints, one of the first question that often arises is how to make your different Blueprints  communicate with each other, and that's what this article is about.</p> <p>This topic can be tricky if you haven't had prior experience with object-oriented programming (OPP), so concepts  covered here can be very abstract at first. You don't have to know everything at first, as you put more time into  Blueperints things will eventually \"click\" in your mind.</p> <p>Tip</p> <p>If you want a more in-depth video showcase on this topic, I highly recommend checking  out Zak Parrish's Live Training video on Blueprint Communication.  </p>"},{"location":"ue5/blueprint-communication/#communicating-between-blueprints","title":"Communicating between Blueprints","text":"<p>Communication between Blueprints will always involve the following:  </p> <ul> <li>A Sender Blueprint</li> <li>At least one Receiver Blueprint</li> </ul> <p>For Blueprints to communicate at the most basic level, one of them has to have a reference to the other.</p> <p>Note</p> <p>Blueprints does not have a way to just send a broad signal to \"everyone\". Either the Sender has to know  about the Receiver, or vice versa. In other words, communication requires a reference at some point.</p>"},{"location":"ue5/blueprint-communication/#getting-an-object-reference","title":"Getting an object reference","text":"<p>Communication at the most basic level always requires a reference at some point, but knowing how to get a reference can be  tricky. There are a variety of ways to get a reference depending on what you're trying to do.</p> <p>Examples of common ways to get references</p> Tracing (Raycasting)Collision EventsSpawn a new actorGetters of Framework Classes <p> Example: Reference from a LineTrace (Raycast) hit result </p> <p> Example: Reference from Trigger Box Begin Overlap event </p> <p> Example: Reference from spawning an Actor </p> <p> Example: Getters of Framework Classes  These are accessable from most Blueprints </p> <p>Warning</p> <p>The <code>GetActorOfClass</code> and <code>GetAllActorsOfClass</code> nodes should almost never be used for anything other than  prototyping purposes. Nodes like this iterate through all of the actors in your level and can therefore  causes a huge performance hit. Use with caution!</p>"},{"location":"ue5/blueprint-communication/#communication-types","title":"Communication Types","text":"<p>At the most basic level, there are 3 ways for Blueprints to communicate with each other:</p> <ul> <li> <p>Casting</p> </li> <li> <p>Event Dispatcher</p> </li> <li> <p>Blueprint Interface</p> </li> </ul>"},{"location":"ue5/blueprint-communication/#casting","title":"Casting","text":"<p>Casting allows for direct communication from the Sender to the Receiver.</p> <p>Once the Sender has a reference to the Receiver, casting is needed to specify to the compiler  what type of object you're working with. By casting, you're telling the compiler to assume \"Object X is of type Type Y\".  When this happens, you'll get full access to \"Type Y's\" functions and properties!</p> <p>When to use Casting:</p> <ul> <li>When you need a quick and easy way for a Sender to communicate with one specific Receiver</li> <li>When the Sender knows exactly who the Receiver is going to be beforehand.</li> </ul> <p>Casting Example</p> Step 1Step 2Step 3 <p> Initiate the cast </p> <p> We now have access to the functions and properties that we want to communicate with              </p> <p> We can now communicate with the other Blueprint! </p> Downsides to Casting <p>Casting is easy and convenient, but it has some downsides too. If you're starting out you don't have to worry about it  much but it's worth mentioning so you can start thinking about good Blueprint hygine:  </p> <ul> <li> <p>Casting creates a dependency on the Blueprint you're casting to, if you were to delete the Blueprint you've previously  casted to, you would have to clean up the casts too. This can become messy if you have a lot of casts in many different  places. Blueprint Interfaces is an alternative if this becomes a concern.</p> </li> <li> <p>Casting creates a hard reference to an object. This will cause the object to always load the object you're  casting to into memory. If you want to know more about hard references check out my  Hard and Soft References guide. A quick tip if this becomes a concern is to utilize Blueprint Interfaces more.</p> </li> <li> <p>If you cast every tick, or cast at the same time from many different blueprints (e.g on Begin Play), slowdowns and hiccups can  occur. This starts to become noticable after hundreds of simultanious casts however, so don't worry about it too much.  A tip is to cast once on BeginPlay and save the output to a variable that you can use several times.</p> </li> </ul>"},{"location":"ue5/blueprint-communication/#event-dispatcher","title":"Event Dispatcher","text":"<p>Event Dispatchers allows for the Receiver to bind itself to the Sender and wait for it to do something. </p> <p>Unlike Casting and Blueprint Interfaces, Event Dispatchers does not require the Sender to have a reference to the Receiver.  Instead the Receiver is the one with the reference and \"subscribes\" (binds) to the Sender. Once the Sender dispatches an  event call, every Receiver that \"subscribed\" to this dispatcher will receieve a \"signal\" and trigger an event. This is especially useful if you have a lot of Receivers that needs to react to the Sender doing something.</p> <p>When to use Event Dispatcher:</p> <ul> <li>If you have one Sender that needs to communicate with many different Receivers at the same time.</li> <li>If the Receiver is the one with a reference to the Sender and not the other way around.</li> </ul> <p>Event Dispatcher Example</p> Step 1Step 2Step 3Step 4Step 5 <p> Create the Event Dispatcher on the Sender </p> <p> Now the sender can Call the Event Dispatcher when it wants to communicate with the Receivers              </p> <p> This is all that needs to be done from the Sender. On the next step we can see             how the receiver binds to this Event Dispatcher </p> <p> This is the receiver blueprint, we need to make it bind to the OnPawnDeath event. </p> <p> Now the event GameOver is bound to the OnPawnDeath Event Dispatcher. GameOver will trigger             when the sender calls OnPawnDeath </p>"},{"location":"ue5/blueprint-communication/#blueprint-interface","title":"Blueprint Interface","text":"<p>Blueprint Interfaces allows the Sender to communicate with a Receiver in a generic way, even when the Sender  doesn't know what kind of Receiver it is.</p> <p>For instance, you can make an \"Interact\" interface, and use it to communicate with any object you happen to click on. Interfaces doesn't even care what you're interfacing with, or if the Receiver even has an implementation of your  interface to begin with. You can simply send an interface message to anything you want, and if the Receiver cares; it  will do something, if the Receiver doesn't care; nothing will happen.</p> <p>For Blueprint Interfaces to work, you have to create a Blueprint Interface asset in the Content Browser. You also have to implement the interface on the Receivers.</p> <p>When to use Blueprint Interface:</p> <ul> <li>If you have a Sender that wants to communicate with a Receiver, but you don't care who the Receiver even is.</li> <li>If you want one generic way to communicate with different kinds of Blueprints.</li> <li>If you want to avoid dependencies and hard-referencing Blueprints.</li> </ul> <p>Blueprint Interface Example</p> Step 1Step 2Step 3Step 4Step 5Step 6Step 7 <p> Create the Blueprint Interface asset in the Content Browser. </p> <p> Open the Blueprint Interface asset and create a function that will serve as our Interface Message.              </p> <p> Now, any Sender can send this Interface Message to any Receiver. </p> <p> In this example, we create a line trace and we send an interface message to any actor that happens to get hit by the trace. </p> <p> For the Receiver to react to the Interface Message, it has to implement the Interface.              You do this in the Receiver's Class Settings. </p> <p> Now the Receiver has the options to implement the function that we defined in the Blueprint Interface Asset. </p> <p> Now the Receiver is ready to receive any \"Interact\" messages thrown at it, and it will react accordingly. </p>"},{"location":"ue5/changing-fov-scaling-methods/","title":"Changing FOV Scaling Methods","text":"<p>The aspect ratio constraint (aka FOV scaling method) can be set in the <code>LocalPlayer-&gt;AspectRatioAxisConstraint</code>. The variable is of an EAspectRatioAxisConstraint  type and can hold the following values:</p> EAspectRatioAxisConstraint <code>AspectRatio_MaintainYFOV</code> <code>AspectRatio_MaintainXFOV</code> <code>AspectRatio_MajorAxisFOV</code> <code>AspectRatio_MAX</code>"},{"location":"ue5/changing-fov-scaling-methods/#how-to-set-the-aspect-ratio-constraint","title":"How to set the Aspect Ratio Constraint","text":"<p>You can set the variable through the DefaultEngine.ini or through C++.</p> <p>Example</p> DefaultEngine.iniC++ <pre><code>[/Script/Engine.LocalPlayer]\nAspectRatioAxisConstraint = AspectRatio_MaintainYFOV\n</code></pre> MyPlayerController.cpp<pre><code>if (GetLocalPlayer())\n{\n    GetLocalPlayer()-&gt;AspectRatioAxisConstraint = EAspectRatioAxisConstraint::AspectRatio_MaintainYFOV;\n}\n</code></pre>"},{"location":"ue5/custom-console-commands/","title":"WIP","text":""},{"location":"ue5/custom-log-categories/","title":"WIP","text":""},{"location":"ue5/gas-notes/","title":"GAS related notes","text":""},{"location":"ue5/gas-notes/#important-gas-parts","title":"Important GAS parts","text":""},{"location":"ue5/gas-notes/#ability-system-component-uabilitysystemcomponent","title":"Ability System Component (<code>UAbilitySystemComponent</code>)","text":"<p>The brain, or manager of abilities. Keeps track of granted abilities, and handles activating, canceling them etc. This component is often attached to actors that you want to be responsible for instigating abilities, like Player Characters and AI Characters.</p> <p>Note</p> <p>Abilities in GAS has the concept of a \"source\" and a \"target\". The <code>UAbilitySystemComponent</code> that owns and activates an ability will be treated as the \"source\" of that ability.</p>"},{"location":"ue5/gas-notes/#gameplay-tags","title":"Gameplay Tags","text":"<p>Text tags used for many things related to the ability system. For instance, tagging certain abilities with \"healing\" for the AI to know which abilities are healing abilities etc. You can also tag stuff as \"cancellable\" for the system to look for cancellable abilities and cancel them etc etc.</p>"},{"location":"ue5/gas-notes/#gameplay-attributes","title":"Gameplay Attributes","text":"<p>Numeric data values that has a concept of a \"current value\" and a \"default value\". Basically \"stats\" that can be used to calculate gameplay ability related effects. E.g Health, Strength, WeaponDamge</p> <p>Warning</p> <p>Modifying Attributes directly through code should be avoided. This should instead be handled with Gameplay Effects, as they're much easier to track and debug.</p>"},{"location":"ue5/gas-notes/#attribute-sets-uattributeset","title":"Attribute Sets (<code>UAttributeSet</code>)","text":"<p>A collection of Gameplay Attributes. Has a handful of overridable function that can handle logic when attributes changes.</p>"},{"location":"ue5/gas-notes/#gameplayability-ugameplayability","title":"GameplayAbility (<code>UGameplayAbility</code>)","text":"<p>A very flexible class that defines what an ability does, what is costs. The actual behaviour of an ability is scripted in this, and it has a lot of flexible ways to handle timings of abilities based on animations, particles, sounds, different types of inputs etc. It also has handy tools to sync, predict and replicate ability behaviour in online environments.</p>"},{"location":"ue5/gas-notes/#gameplay-effect-ugameplayeffect","title":"Gameplay Effect (<code>`UGameplayEffect</code>)","text":"<p>Data only Blueprints that define how attributes are changed within the GAS system. Direct changes like HP loss, over time changes like regeneration effects, temporary changes  like buffs and debuffs are some of the things you can define with these.</p> <p>Note</p> <p>It is recommended to use Gameplay Effects as much as possible to modify attributes, as opposed to modifying them directly through code. Gameplay Effects are much easier to track and debug, while modifying attributes directly through code can become messy.</p>"},{"location":"ue5/gas-resources/","title":"GAS Resources","text":"<p>Gameplay Ability System | Unreal Engine Documentation</p> <p>GASDocumentation by tranek</p> <p>Action RPG Sample Project by Epic</p> <p>Unreal Slackers Discord's GAS channel</p> <p>GitHub repository of resources by Dan 'Pan'</p>"},{"location":"ue5/handling-local-players-online/","title":"Handling Local \"Splitscreen\" Players in an Online Session","text":""},{"location":"ue5/handling-local-players-online/#removing-non-primary-players-from-the-session","title":"Removing non-primary players from the session","text":"<p>There is not supported server-sided operation to remove a non-primary player (\"local splitscreen player\") the way  <code>UGameplayStatics::RemovePlayer</code> or <code>UGameInstance::RemoveLocalPlayer</code> would. A workaround is to make the client-instance remove the player themselves through a client RPC.</p>"},{"location":"ue5/handling-local-players-online/#differenciating-between-primary-players-and-non-primary-players","title":"Differenciating between primary players and non-primary players","text":"<p>Non-Primary players (\"local splitscreen players\") use a <code>UChildConnection</code> rather than the primary player's <code>UNetConnection</code>.  From the server, you can cast to the PlayerController's <code>UChildConnection</code> to see if it's a primary player or not.</p> <pre><code>Cast&lt;UChildConnection&gt;(PC-&gt;Player)\n</code></pre>"},{"location":"ue5/hard-soft-references/","title":"Hard and Soft References","text":""},{"location":"ue5/hard-soft-references/#intro","title":"Intro","text":"<p>As a project becomes big, you might notice that that editor and loading times becomes big. This is usually a sign of poor dependency and memory management, and a heavy use of Hard References.</p> <p>Tip</p> <p>If you want a more in-depth video showcase on this topic, I highly recommend checking out Demystifying Soft Object References | Inside Unreal.</p>"},{"location":"ue5/hard-soft-references/#hard-references","title":"Hard References","text":"<p>Hard references creates a dependency on the asset you're referencing to. When an assets gets loaded in Unreal, it first synchronously loads all the dependencies of that asset. This can create a long chain of assets that has to be synchronously loaded. It's important to keep track of these references as they tend to go out of hand. I've seen crazy stuff in my career, like a main menu having a dependency on the final boss, through a long chain of references. </p> <p>Some ways hard references gets created that might not be obvious: * Anytime your asset has a variable containing a hard object reference to another asset * Anytime your asset casts to another asset * Anytime your asset has events/functions with inputs/output pins of another asset * If a component's defaults get set to specific assets (like a mesh, or a material)</p>"},{"location":"ue5/hard-soft-references/#soft-references","title":"Soft References","text":"<p>Soft references creates a \"soft\" dependency. It references assets without being forced to load the asset in memory, instead you manually load the asset before you use it. Not only do you decide when to load the asset in question, you can also load it asynchronously. It's recommended to make heavy use of soft references on assets that take a lot of space in memory. Things like meshes, textures, materials, particles, sounds, or any objects/classes/data containers with hard references to big assets.</p> <p>Tip</p> <p>It's important to occasionally use the Reference Viewer to get a quick overview of asset references and make sure things are as they should. Size Map is another tool that can be useful to find assets with outlier memory-hogging references.</p>"},{"location":"ue5/inheritance-vs-composition/","title":"Inheritance vs Composition","text":""},{"location":"ue5/inheritance-vs-composition/#intro","title":"Intro","text":"<p> Inheritance and composition are both important design patterns in OOP. Even though compositional patterns are commonly preferred in the modern game-programming paradigm, both are heavily used in Unreal Engine. In this article we're gonna go though the pros and cons of both.</p>"},{"location":"ue5/inheritance-vs-composition/#inheritance","title":"Inheritance","text":"<p>Inheritance can be useful when there is shared functionality between classes that share an \"is-a\" relationship, especially if the shared functionality has to be tightly coupled and isn't used outside of said inheritance hierarchy.</p> <p>Pros</p> <ul> <li>Performant if used correctly</li> <li>Convenient</li> <li>Intuitive linear structures of systems</li> </ul> <p>Cons</p> <ul> <li>Inflexible</li> <li>Hard to modify and extend</li> <li>Deep nesting is hard to maintain</li> </ul>"},{"location":"ue5/inheritance-vs-composition/#composition","title":"Composition","text":"<p>Composition based programming is widely used in video game development because of its modularity and flexibility. This is mostly done through heavy use of components. This is especially useful if you want to compartmentalize features that you want to reuse in a variety of classes and contexts, and if classes and systems are going to be changed a lot during development.</p> <p>Pros</p> <ul> <li>Flexible</li> <li>Scalable</li> <li>Encourages modularity</li> <li>Encourages encapsulation</li> <li>Easy to test different features in isolation</li> </ul> <p>Cons</p> <ul> <li>Hard to understand when many components interact</li> <li>Can become hard to debug if many components interact</li> </ul>"},{"location":"ue5/inheritance-vs-composition/#inheritance-vs-composition","title":"Inheritance vs composition","text":"<p>In general, composition should be favored over inheritance. The requirements in game development tend to change a lot, and composition is a flexible and modular pattern that can save a lot of time during rapid changes. </p> <p>Composition promotes encapsulation of different features which creates a lot of advantages. It makes your features modular, flexible, clear, easy to test and debug. Composition allows for designer to experiment and compose new classes that leverage already existing code, in contexts that was previously not planned for.</p> <p>Composition can become complicated and hard to manage if a lot of components rely on each other however, and should still be carefully planned to ensure loose coupling and high cohesion. </p> <p>Inheritance can be powerful on certain scenarios, but should only really be used if you're sure the code wont change much. Any change on the superclass will cause a ripple effect on all the subclasses, which may result in unexpected problems due to the tight coupling super and subclasses tend to have. If not planned correctly, you tend to see a lot of implementations and properties in the subclasses that never gets used, creating a lot of confusion and uncertainty when trying to understand how the class works.</p>"},{"location":"ue5/profiling-tools/","title":"WIP","text":""},{"location":"ue5/replicated-properties-vs-rpcs/","title":"WIP","text":""},{"location":"ue5/routing-gamepad-input-standalone/","title":"Routing gamepad input to focused Standalone Game Window","text":"<p>The default behaviour of a PIE Standalone Game is to route inputs to all PIE sessions even when the window is not focused.  This is especially problematic when you're dealing with multiple PIE windows (while testing out online features for instance)  but you only want to route controller inputs to one window at a time.</p> <p>There is a CVar you can enable to only route gamepad input to the focused window: <pre><code>Slate.RequireFocusForGamepadInput 1\n</code></pre></p>"},{"location":"ue5/simulating-lag/","title":"Simulating Lag","text":""},{"location":"ue5/simulating-lag/#packet-simulation-settings","title":"Packet Simulation Settings","text":"Setting Description <code>PktLag</code> Sets network packet lag (specified in ms) <code>PktLagVariance</code> Sets a variable network packet lag (\u00b1 the amount specified in ms) <code>PktLoss</code> Simulates outgoing packet loss (specified in percent) <code>PktIncomingLoss</code> Simulates incoming packet loss (specified in percent) <code>PktDub</code> Simulates sending/receiving duplicate packets (specified in percent) <code>PktOrder</code> Simulates network packets received out of order (1 = enabled, 0 = disabled) <p>More settings can be found in the  FPacketSimulationSettings docs</p>"},{"location":"ue5/simulating-lag/#how-to-apply-packet-simulation-settings","title":"How to apply Packet Simulation settings","text":"<p>These settings can be set in <code>DefaultEngine.ini</code> </p> DefaultEngine.ini<pre><code>[PacketSimulationSettings]\nPktLag=250\nPktLagVariance=20\nPktLoss=10\nPktDup=0\nPktOrder=1\n</code></pre> <p>These settings can be set through the console</p> Console<pre><code>NetEmulation.PktLag 300\n</code></pre> <p>Some of these settings can be set directly in the Project Settings</p> <p></p>"},{"location":"ue5/smooth-transition-gameplay-cutscenes/","title":"WIP","text":""},{"location":"ue5/waiting-for-players-finish-loading/","title":"WIP","text":""}]}